{"google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Plant","tagline":"A generic helper factory for .NET","body":"Plant\r\n=====\r\n\r\nPlant is a test factory for .NET 4.0.  It is very much like FactoryGirl (http://github.com/thoughtbot/factory_girl/) for Ruby.  The goal of this project is to allow you to reduce noise and duplication across your tests when creating models.  \r\n\r\nFeatures\r\n--------\r\n\r\nCurrently Plant supports\r\n\r\n* Object creation via properties\r\n* Object creation by constructor arguments\r\n* Overriding default property and constructor argument values\r\n* Modular object definition\r\n* Lazily evaluated property and constructor argument values\r\n* Sequenced properties\r\n* Allow user to specify after-create actions on models (to save the model to the DB after creation, for instance)\r\n\r\nTargetted features can be found in the issues list for the project.  Some specific ones are\r\n\r\n* Allowing multiple different definitions for one object\r\n* Specify associated instances\r\n\r\n\r\nTerms\r\n-----\r\n\r\nA 'Plant' is the thing that creates your objects for you.  \r\nA 'Blueprint' is what a user provides to tell a plant how to create an object.\r\n\r\nDefining a Blueprint\r\n--------------------\r\n\r\nA Blueprint is just a class that implements the Blueprint interface.  The interface defines one method, SetupPlant, which takes a BasePlant object.  SetupPlant is a generic method which whose generic argument is the Type that you're setting up and an anonymous object with the appropriate properties.\r\n\r\nNote that currently property validation occurs during object creation, not DefinePropertiesOf.\r\n\r\n    class PersonBlueprint : Blueprint\r\n    {\r\n      public void SetupPlant(BasePlant plant)\r\n      {\r\n        plant.DefinePropertiesOf<Person>(new\r\n                               {\r\n                                  FirstName = \"Barbara\",\r\n                                  MiddleName = \"Elaine\",\r\n                                  LastName = \"Brechtel\",\r\n                                  Address = \"111 South Main St.\",\r\n                                  City = \"Gulfport\",\r\n                                  State = \"MS\",\r\n                                  EmailAddress = \"barbara@brechtel.com\"s\r\n                               });\r\n      }\r\n    }\r\n  \r\nUse DefineConstructionOf instead of DefinePropertiesOf when an object should be created via constructor arguments.\r\n\r\n    class PersonBlueprint : Blueprint\r\n    {\r\n      public void SetupPlant(BasePlant plant)\r\n      {\r\n        plant.DefineConstructionOf<Person>(new\r\n                               {\r\n                                  FirstName = \"Barbara\",\r\n                                  MiddleName = \"Elaine\",\r\n                                  LastName = \"Brechtel\",\r\n                                  Address = \"111 South Main St.\",\r\n                                  City = \"Gulfport\",\r\n                                  State = \"MS\",\r\n                                  EmailAddress = \"barbara@brechtel.com\"s\r\n                               });\r\n      }\r\n    }\r\n\r\nLazily evaluated properties\r\n---------------------------\r\n\r\nTo define a Blueprint with a lazily evaluated property, set the value to new LazyProperty<TPropertyType>(lambda) like so:\r\n\r\n    class PersonBlueprint : Blueprint\r\n    {\r\n      public void SetupPlant(BasePlant plant)\r\n      {\r\n        plant.DefinePropertiesOf<Person>(new\r\n                               {\r\n                                  UniqueID = new LazyProperty<int>(() => IDGenerator.GenerateNewID())\r\n                               });\r\n      }\r\n    }\r\n  \r\nwhere TPropertyType (int in this case) is the type of the property and also that returned from the lambda.\r\n\r\nSequenced properties\r\n---------------------------\r\n\r\nTo define a Blueprint property that is evaluated lazily, but with a sequence counter, set the value to new Sequence<TPropertyType>(lambda) like so:\r\n\r\n    class PersonBlueprint : Blueprint\r\n    {\r\n      public void SetupPlant(BasePlant plant)\r\n      {\r\n        plant.DefinePropertiesOf<Person>(new\r\n                               {\r\n                                  ID = new Sequence<int>((sequenceValue) => sequenceValue)\r\n                                  Name = new Sequence<int>((sequenceValue) => \"test: \" + sequenceValue)\r\n                               });\r\n      }\r\n    }\r\n  \r\nwhere TPropertyType (int in this case) is the type of the property and also that returned from the lambda.\r\n  \r\nUsage\r\n-----\r\n\r\nTo create a new Plant, you'll typically want to tell it which Assembly to look in for Blueprints.  You can do this via\r\n\r\n    var plant = new BasePlant().WithBlueprintsFromAssemblyOf<PersonBlueprint>();\r\n  \r\nwhere PersonBlueprint is one of the Blueprints you have defined.  Plant will then load blueprints from any other type that implements the Blueprint interface in that assembly.\r\n\r\nTo retrieve the default instance of an object\r\n\r\n    var person = plant.Create<Person>();\r\n  \r\nTo retrieve an instance of a person with specific parts of the default blueprint overridden\r\n\r\n    var person = plant.Create<Person>(new { EmailAddress = \"john@doe.com\" });\r\n  \r\nMultiple properties can be overridden in one call\r\n\r\n    var person = plant.Create<Person>(new { EmailAddress = \"john@doe.com\", State = \"GA\" });"}